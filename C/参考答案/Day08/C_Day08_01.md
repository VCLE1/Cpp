## 王道训练营C/C++方向

### 题目描述

(a) 什么是结点？什么是链表？有哪几种类型的链表？

(b) 整理单向链表和双向链表的基本操作，为什么在实际生产中更倾向于使用双向链表？

(c) 用单链表实现 LRU 的添加算法。

```c
bool add_item(LRUCache* cache, int item);
```

```c
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>

typedef struct node_s {
	int item;
	struct node_s* next;
} Node;

typedef struct {
	Node* head;
	// item的数目
	int size;
	// LRUCache的容量
	int capacity;
}LRUCache;

LRUCache* LRUCache_create(int capacity);
void add_item(LRUCache* cache, int item);

int main(void) {
	LRUCache* cache = LRUCache_create(5);
	add_item(cache, 1);
	add_item(cache, 2);
	add_item(cache, 3);
	add_item(cache, 1);
	add_item(cache, 4);
	add_item(cache, 5);
	add_item(cache, 6);

	return 0;
}

LRUCache* LRUCache_create(int capacity) {
	LRUCache* cache = (LRUCache*)calloc(1, sizeof(LRUCache));
	if (cache == NULL) {
		printf("Error: calloc failed in LRUCache_create.\n");
		exit(1);
	}
	cache->capacity = capacity;
	return cache;
}

void add_item(LRUCache* cache, int item) {
	// 判断 item 是否存在
	Node* pp = NULL;
	Node* prev = NULL;
	Node* curr = cache->head;
	while (curr != NULL && curr->item != item) {
		pp = prev;
		prev = curr;
		curr = curr->next;
	}
	// item 不能存在
	if (curr == NULL) {
		// 创建新结点
		Node* newNode = (Node*)malloc(sizeof(Node));
		if (newNode == NULL) return;
		newNode->item = item;
        
		if (cache->size == cache->capacity) {
			// 缓存满了, 删除尾结点
			if (pp == NULL) {
				cache->head = NULL;
			}
			else {
				pp->next = NULL;
				free(prev);
			}
			cache->size--;
		}
		// 缓存没满，添加到头结点
		newNode->next = cache->head;
		cache->head = newNode;
		cache->size++;
	}
	else {
		if (prev == NULL) return;
		// 删除当前结点
		prev->next = curr->next;
		// 在头节点添加
		curr->next = cache->head;
		cache->head = curr;
	}
}
```



### 答案

请在下面填写你的答案：

