### 题目描述

(a)  查找一个数组中第K大的元素，看能不能将时间复杂度降到 O(n)。

```c
int partition(int* nums, int left, int right) {
    int pivot = nums[left];
    int i = left;
    int j = right;
    while (i < j) {
        while (i < j && nums[j] >= pivot) {
            j--;
        }
        nums[i] = nums[j];
        while (i < j && nums[i] <= pivot) {
            i++;
        }
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    return i;
}

int find(int* nums, int left, int right, int idx) {
    while (left <= right) {
        int i = partition(nums, left, right);
        if (i < idx) {
            left = i + 1;
        } else if (i > idx) {
            right = i - 1;
        } else {
            return nums[i];
        }
    }
    return -1;
}

int findKthLargest(int* nums, int n, int k){
    return find(nums, 0, n - 1, n - k);
}
```



### 答案

请在下面填写你的答案：


