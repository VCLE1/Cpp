## 王道训练营C/C++方向

### 题目描述

(a) break 语句和 continue 语句有什么区别？

(b) 使用 goto 计算 1-2+3-4+......+99-100 的值。

```c
int main(void) {
	int sum = 0, i = 1;
loop:
	if (i & 0x1) {
		sum += i;
	} else {
		sum -= i;
	}
	i++;
	if (i <= 100) {
		goto loop;
	}
	printf("sum = %d\n", sum);

	return 0;
}
```

(c) 输入一个整数，判断这个数是不是素数。

```c
bool is_prime(int n) {
	for (int i = 2; i * i < n; i++) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}
```

(d) 写程序生成前 100 个素数。

```c
#include <stdio.h>
#include <stdbool.h>

int main(void) {
	int prime[100] = { 2 };
	int n = 1, candidate = 3;
	while (n < 100) {
		bool isPrime = true;
		for (int i = 0; i < n; i++) {
			if (candidate % prime[i] == 0) {
				isPrime = false;
				break;
			}
		}
		if (isPrime) {
			prime[n++] = candidate;
		}
		candidate++;
	}

	for (int i = 0; i < 100; i++) {
		printf("%d ", prime[i]);
	}
	printf("\n");

	return 0;
}
```



### 答案

请在下面填写你的答案：



### 拓展

在密码学领域，我们经常要测试一个非常大 (好几百位) 的正整数是否是素数。采用一般的素数测试方法，效率会很堪忧。工业上采用的是一种称为 Fermat's Test 的随机算法，该算法利用了费马小定理。算法如下：

```
function primality(N)
Input: Positive integer N
Output: yes/no
    
Pick positive integers a1, a2, ..., ak < N at random
if ai^(N-1) ≡ 1 (mod N) for all i = 1, 2, . . . , k:
	return yes
else:
	return no
```











### 





